Perf tuning suggestions by Vlado:
===================================
Transformations on columns used as predicates (i.e. where upper(column_name) = x )
    Remove unnecessary transformations of predicates
    Create expression statistics for the transformation that are needed

  --> We will review user filters across all WFN reports and based on the usage & data, apply default settings to avoid it.

Correlated column used as predicates
    Create column group statistics (and histograms if needed)

  --> We will open a user story to study the usage patterns & catalog joins to find the candidates and test them out.

Persist content of security table and update only as needed (i.e., when the data has changed)
  --> N/A. Can't do this as it opens security risk by introducing a new layer of failure.


Queries based on complex multi-level views which prevent query transformations (i.e. view merging, join predicate pushdown, etc.)
    Remove duplicate transformation logic/data access in views
    Materialize data transformations such that they are performed only when needed (i.e., when the data has changed)

  --> I need to check but we are materializing most of the transformations already. We open a user story to track the work.

Hash partitioning on vpd_key when all queries filter on a specific vpd_key
    List partitions ensure all data blocks accessed contain only the requested vpd_key
    Combine with range partitioning and a moving window (i.e. monthly partitions for a range of +/- x years, otherwise yearly partitions) to reduce partition count

  --> We retest on production data and validate if this gives performance benefit.
      The suggested approach has high maintenance cost and will create stability issues.
      In our prior tests we didnt see andy difference in performance on a large dataset, perhaps due to Oracle vpd level policies.


Partitioned tables without incremental statistics
    Use incremental statistics to reduce resource consumption for stats gathering

   --> We will use this approach as part of regular maintenance.







******************** LOAD TEST **********************************


select runid || ' ' || start_time || ' ' || end_time || ' ' || (end_time-start_time) || ' ' || DESCRIPTION from dwruns order by 1;

3 11-JAN-17 12.14.30.786650 AM 11-JAN-17 02.31.38.940698 AM +000000000 02:17:08.154048
4 13-JAN-17 04.53.13.392155 AM 13-JAN-17 06.20.54.776248 AM +000000000 01:27:41.384093
5 15-JAN-17 10.38.48.660833 AM 15-JAN-17 12.43.22.662658 PM +000000000 02:04:34.001825


select a.req_key, elapsedtosec(a.ELAPSED_TIME), elapsedtosec(b.ELAPSED_TIME)
from DWRUNDETAILS a join DWRUNDETAILS b on (a.req_key = b.req_key)
where a.runid=3 and b.runid=5 and a.num_rows>0 and b.num_rows>0 and
elapsedtosec(a.ELAPSED_TIME) < elapsedtosec(b.ELAPSED_TIME)
and a.req_key in ('1634299966340')
order by 1;


nohup sh DENORMTEST.sh /tmp/testxml/xml_final.log DENORM_TEST_POSTL2L_WITH_STATS > VA.log &
nohup sh DENORMTEST.sh /tmp/testxml/xml_final.log NORM_TEST_POSTL2L_WITH_STATS > VA.log &

nohup sh DENORMTEST.sh /tmp/testxml/xml_final.log DENORM_FIRST_TEST_PAYSTMT_JOBPROF > VA.log &

nohup sh DENORMTEST.sh /tmp/testxml/xml_final.log DENORM_FIRST_TEST2_PAYSTMT_JOBPROF > VA.log &

select count(1) from gv$session where status = 'ACTIVE' and osuser='root';
select module, last_call_et, sql_id from gv$session where status = 'ACTIVE' and osuser='root'

select SESSION_STATE, sql_id, session_type from gv$active_session_history where status = 'ACTIVE';


select session_state, count(1) from gv$active_session_history where
machine = 'dc2prwfn4arwb02'
and sample_time > to_date('01/15/2017 10:38:00', 'MM/DD/YYYY HH24:MI:SS')
group by session_state;


exec DBMS_APPLICATION_INFO.SET_MODULE('1634299966340', 'VPDRUN');
exec DBMS_APPLICATION_INFO.SET_MODULE('1634299966340', 'SQLRUN');


select
'0REQ_KEY,SQLTIME,REQ_ROWS,NORMTIME,NORMROWS,DENORMTIME,DENORMROWS'
from dual;

select a.req_key, dw.sqltime origtime, dw.req_rows origrows,
elapsedtosec(a.ELAPSED_TIME) normtime, a.NUM_ROWS normrows,
elapsedtosec(b.ELAPSED_TIME) denromtime, b.NUM_ROWS denormrows

select a.req_key ||','|| dw.sqltime||','|| dw.req_rows||','||
elapsedtosec(a.ELAPSED_TIME) ||','|| a.NUM_ROWS ||','||
elapsedtosec(b.ELAPSED_TIME) ||','|| b.NUM_ROWS  data
from DWRUNDETAILS a join DWRUNDETAILS b on (a.req_key = b.req_key)
join dwworkload dw on (a.req_key = dw.req_key)
where a.runid=8 and b.runid=7 and a.num_rows>0 and b.num_rows>0
order by 1;




select tname from tab where tname like 'DW%';

alter table DWWORKLOAD add (vpdtime number, sqltime number);
alter table dwworkloadbkp add (req_rows number);



select * from batreqlog where req_key = '1635390791440';


select
extract(day from (vpdtime)*86400) vpdtime,
extract(day from (sqltime)*86400) sqltime
from (
select
((select RLOG_TIMESTAMP from batreqlog where RLOG_SUBSTATUS='TABLES' and req_key = '1635390791440')
  -
(select RLOG_TIMESTAMP from batreqlog where RLOG_SUBSTATUS='SECURITY' and req_key = '1635390791440')) vpdtime,
((select RLOG_TIMESTAMP from batreqlog where RLOG_SUBSTATUS='OUTPUTXML' and req_key = '1635390791440')
  -
(select RLOG_TIMESTAMP from batreqlog where RLOG_SUBSTATUS='DATAMART' and req_key = '1635390791440')) sqltime
from dual
)








-- update timings for each req key in WFN DW Workload.
merge into dwworkloadbkp d
using (
    select
    req_key,
    extract(day from (vpdtime)*86400) vpdtime,
    extract(day from (sqltime)*86400) sqltime
    from (
    select b.req_key,
    ((select RLOG_TIMESTAMP from ADPRMASPRD03.batreqlog@dblinkcru40ptocrw13p where RLOG_SUBSTATUS='TABLES' and req_key = b.req_key)
      -
    (select RLOG_TIMESTAMP from ADPRMASPRD03.batreqlog@dblinkcru40ptocrw13p where RLOG_SUBSTATUS='SECURITY' and req_key = b.req_key)) vpdtime,
    ((select RLOG_TIMESTAMP from ADPRMASPRD03.batreqlog@dblinkcru40ptocrw13p where RLOG_SUBSTATUS='OUTPUTXML' and req_key = b.req_key)
      -
    (select RLOG_TIMESTAMP from ADPRMASPRD03.batreqlog@dblinkcru40ptocrw13p where RLOG_SUBSTATUS='DATAMART' and req_key = b.req_key)) sqltime
    from dwworkloadbkp d join ADPRMASPRD03.batreq@dblinkcru40ptocrw13p b on (d.req_key = b.req_key)
    )
) x
on (d.req_key = x.req_key)
when matched then update set d.vpdtime = x.vpdtime, d.sqltime = x.sqltime;


merge into dwworkload d
using (select b.req_key, b.req_rows
     from dwworkload d join ADPRMASPRD03.batreq@dblinkcru40ptocrw13p b on (d.req_key = b.req_key)
) x
on (d.req_key = x.req_key)
when matched then update set d.req_rows = x.req_rows;




merge into dwworkload d
using (select * from dwworkloadbkp) x
on (d.req_key = x.req_key)
when matched then update set d.vpdtime = x.vpdtime, d.sqltime = x.sqltime;









******************** BUSINESS RULES / VALIDATION TABLES **********************************



SELECT VPD_KEY||'-'||COMPANY_CODE,COUNT(*) FROM
(SELECT POS.VPD_KEY,DECODE( F_PAID,1,PA.COMPANY_CODE,POS_AD.COMPANY_CODE) COMPANY_CODE
FROM <SCHEMANAME_PARAM>.CHR_EMP_POSITION POS,
<SCHEMANAME_PARAM>.PAYROLL_AGREEMENT PA,
<SCHEMANAME_PARAM>.CHR_EMP_POS_ADDITIONAL POS_AD,
<SCHEMANAME_PARAM>.COMPANY_CODE COMP
WHERE 1=1 AND POS.VPD_KEY = PA.VPD_KEY(+)
AND POS.PAID = PA.PAID(+)
AND POS.PFID = POS_AD.PFID(+)
AND POS.VPD_KEY = POS_AD.VPD_KEY(+)
AND PA.COMPANY_CODE = COMP.CO_CODE(+)
AND PA.VPD_KEY = COMP.VPD_KEY(+) )
GROUP BY VPD_KEY,COMPANY_CODE ORDER BY VPD_KEY ASC;


SELECT VPD_KEY||'-'||COMPANY_CODE,COUNT(*) FROM
(SELECT pos.VPD_KEY,DECODE( F_PAID,1,pos.COMPANY_CODE,POSADD_COMPANY_CODE) COMPANY_CODE
FROM <SCHEMANAME_PARAM>.T_WFN_RPTG_JOB_PRFL pos)
GROUP BY VPD_KEY,COMPANY_CODE ORDER BY VPD_KEY ASC





FIT SCHEMAS:
============

-- most used FIT WFN schemas:

with wfnmappings as (
select 'wfc31q' dbname, wfn_schema_name, adpr_region_name, version from ggate.wfn_adpr_mapping@dblinkcrw11qtowfc31q
union
select 'wfc33q' dbname, wfn_schema_name, adpr_region_name, version from ggate.wfn_adpr_mapping@dblinkcrw11qtowfc33q
union
select 'wfc53q' dbname, wfn_schema_name, adpr_region_name, version from ggate.wfn_adpr_mapping@dblinkcrw11qtowfc53q
)
select w.wfn_schema_name, w.dbname, bcp.bcp_extension_value, count(1) from
batclientproduct bcp join batclientenvironment bce on (bcp.client_code = bce.client_code
and bcp.prd_code = bce.prd_code and bcp.prd_code = 'WFN' and bcp.ver_code = '11')
join batreq br on (br.client_code = bce.client_code and br.req_timestamp > trunc(sysdate)-100)
join batinstance bi on (bi.inst_key = bce.inst_key)
join wfnmappings w on (lower(substr(bi.inst_sid, 1, 6)) = w.dbname and '_' || w.adpr_region_name = bcp.bcp_extension_value)
group by w.wfn_schema_name, w.dbname, bcp.bcp_extension_value order by 4;


WFN11SCHREPORT_FIT1				   wfc53q _0008 	     4
WFN9SCH053TLM					   wfc53q _0006 	     6
WFN12SCH000131					   wfc31q _0004 	   189
WFN9SCH000031					   wfc31q _0003 	   738
WFN9SCH000053					   wfc53q _0007 	  2088

select * from (select vpd_key, count(1) from WFN9SCH000053.chr_associate group by vpd_key order by 2 desc) where rownum < 100;

WNVPD0049645

exec sp_set_vpd_ctx('WNVPD0049645');



 
   
  
  





s
